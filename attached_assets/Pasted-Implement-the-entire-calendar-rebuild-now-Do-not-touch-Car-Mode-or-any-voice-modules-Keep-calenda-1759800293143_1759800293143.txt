Implement the entire calendar rebuild now.
Do not touch Car Mode or any voice modules. Keep /calendar-proxy working during the swap. Goal: a single, proxy-based calendar stack with no duplicates.

Scope (must do)

Quarantine ALL old calendar code (don’t delete):

Move to z_deprecated/:

src/modules/calendarMulti/**

any calendar-multi/** mounts

any old alias stores not using calendar_credentials.db

any “quick action” calendar handlers for the old calendar

Remove their mounts/imports from src/index.ts.

Do not move or modify Car Mode files/routes; leave as-is.

Create the clean stack (proxy-only):

Routes that must exist after rebuild:

/calendar-cred/* – saves Web App URL + Shared Token and up to 10 colleague aliases (email + ICS URL)

/calendar-book/* – NLP + booking via proxy (GAS web app)

/calendar-proxy/* – keep the existing working router; if missing, create the minimal one below

Env: CALENDAR_BACKEND=proxy (Deployment secrets)

Wire only once in src/index.ts:

app.use("/calendar-cred", …)

app.use("/calendar-book", …)

app.use("/calendar-proxy", …) (existing module)

Remove any other calendar mounts.

UI: Keep the existing Calendar Credentials panel (or add it if missing). It must:

Save connector: POST /calendar-cred/user with { userId, webAppUrl, sharedToken } (auto-registers /calendar-proxy)

Save rows: POST /calendar-cred/colleague with { alias, email?, icsUrl? } (up to 10)

No overlaps with “quick actions”; the agent and chat route use the saved creds automatically.

Acceptance tests (must pass):

After saving connector + one colleague:

POST /calendar-book/command with
{"userId":"PRIMARY_USER","text":"create a team meeting today at 12:30 with \"boss\" for 30 minutes","tz":"America/Vancouver","workHours":{"start":"09:00","end":"18:00"}}
→ returns { eventId, htmlLink }

POST /calendar-book/command with
{"userId":"PRIMARY_USER","text":"find a free slot today with \"boss\" for 30m"}
→ returns { intent:"find_free", windows:[...] } (0–5 windows)

/health returns { ok:true, backend:"proxy" }

Zero-downtime swap & rollback:

Keep current /calendar-proxy live.

Add new routes, run acceptance tests.

Commit: feat(calendar): unify to proxy-only stack; deprecate legacy

If any acceptance test fails, revert mounts to previous state and report the failing step + response body.

Files to add (verbatim)

src/modules/calendarCred/index.ts

import express from "express";
import Database from "better-sqlite3";

const router = express.Router();
const db = new Database("calendar_credentials.db");
db.exec(`
CREATE TABLE IF NOT EXISTS user_connector (
  user_id TEXT PRIMARY KEY,
  web_app_url TEXT NOT NULL,
  shared_token TEXT NOT NULL,
  updated_at INTEGER NOT NULL
);
CREATE TABLE IF NOT EXISTS colleagues (
  alias TEXT PRIMARY KEY,
  email TEXT,
  ics_url TEXT,
  updated_at INTEGER NOT NULL
);
`);

function upsertConnector(userId: string, webAppUrl: string, sharedToken: string) {
  const now = Date.now();
  db.prepare(`
    INSERT INTO user_connector(user_id,web_app_url,shared_token,updated_at)
    VALUES(?,?,?,?)
    ON CONFLICT(user_id) DO UPDATE SET
      web_app_url=excluded.web_app_url,
      shared_token=excluded.shared_token,
      updated_at=excluded.updated_at
  `).run(userId, webAppUrl, sharedToken, now);
}
function readConnector(userId: string) {
  return db.prepare(`SELECT user_id, web_app_url, shared_token FROM user_connector WHERE user_id=?`).get(userId);
}
function upsertColleague(alias: string, email?: string, ics?: string) {
  const now = Date.now();
  db.prepare(`
    INSERT INTO colleagues(alias,email,ics_url,updated_at)
    VALUES(?,?,?,?)
    ON CONFLICT(alias) DO UPDATE SET
      email=excluded.email,
      ics_url=excluded.ics_url,
      updated_at=excluded.updated_at
  `).run(alias.toLowerCase(), email || null, ics || null, now);
}
function deleteColleague(alias: string) {
  db.prepare(`DELETE FROM colleagues WHERE alias=?`).run(alias.toLowerCase());
}
function listColleagues() {
  return db.prepare(`SELECT alias,email,ics_url,updated_at FROM colleagues ORDER BY alias`).all();
}

router.get("/state", (req, res) => {
  const userId = String(req.query.userId || "PRIMARY_USER");
  res.json({ userId, connector: readConnector(userId) || null, colleagues: listColleagues() });
});

router.post("/user", async (req, res) => {
  const { userId, webAppUrl, sharedToken } = req.body || {};
  if (!userId || !webAppUrl || !sharedToken) return res.status(400).json({ error: "userId, webAppUrl, sharedToken required" });
  upsertConnector(userId, webAppUrl, sharedToken);
  const origin = `${req.protocol}://${req.get("host")}`;
  const r = await fetch(`${origin}/calendar-proxy/register`, {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId, webAppUrl, sharedToken })
  });
  const j = await r.json().catch(() => ({}));
  if (!r.ok) return res.status(400).json({ error: "Register failed", detail: j });
  res.json({ ok: true, registered: true });
});

router.post("/colleague", (req, res) => {
  const { alias, email, icsUrl } = req.body || {};
  if (!alias) return res.status(400).json({ error: "alias required" });
  if (!email && !icsUrl) return res.status(400).json({ error: "email or icsUrl required" });
  upsertColleague(String(alias), email ? String(email) : undefined, icsUrl ? String(icsUrl) : undefined);
  res.json({ ok: true });
});

router.delete("/colleague/:alias", (req, res) => {
  const alias = String(req.params.alias || "").toLowerCase();
  if (!alias) return res.status(400).json({ error: "alias required" });
  deleteColleague(alias);
  res.json({ ok: true });
});

export default router;


src/modules/calendarBook/service.ts

import Database from "better-sqlite3";
const db = new Database("calendar_credentials.db");

function getConnector(userId: string) {
  return db.prepare(`SELECT web_app_url AS webAppUrl, shared_token AS sharedToken FROM user_connector WHERE user_id=?`).get(userId);
}
function getColleague(alias: string): { email?: string; ics_url?: string } | undefined {
  return db.prepare(`SELECT email, ics_url FROM colleagues WHERE alias=?`).get(alias.toLowerCase());
}

async function callGAS(url: string, payload: any) {
  const r = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
  const txt = await r.text();
  let data: any = null; try { data = JSON.parse(txt); } catch {}
  if (!r.ok) throw new Error(data?.error || txt || `GAS ${r.status}`);
  if (data?.error) throw new Error(String(data.error));
  return data;
}

export async function scheduleViaProxy(userId: string, args: {
  title: string; date: string; preferredStart?: string | null; durationMins: number; tz: string;
  workHours?: { start: string; end: string }; attendeeAlias?: string;
}) {
  const c = getConnector(userId);
  if (!c) throw new Error("No connector saved for this userId. Open Calendar Credentials and Save Connector.");
  const body: any = {
    action: "schedule",
    sharedToken: c.sharedToken,
    title: args.title, date: args.date,
    preferredStart: args.preferredStart || undefined,
    durationMins: args.durationMins, tz: args.tz,
    workHours: args.workHours || { start: "09:00", end: "18:00" }
  };
  if (args.attendeeAlias) {
    const hit = getColleague(args.attendeeAlias);
    if (hit?.ics_url) body.coworkerICS = hit.ics_url;
    if (hit?.email) body.attendeeEmail = hit.email;
  }
  return await callGAS(c.webAppUrl, body);
}

export async function freeViaProxy(userId: string, args: {
  date: string; durationMins: number; tz: string; workHours?: { start: string; end: string }; attendeeAlias?: string;
}) {
  const c = getConnector(userId);
  if (!c) throw new Error("No connector saved for this userId.");
  const body: any = {
    action: "getFreeSlots",
    sharedToken: c.sharedToken,
    date: args.date, durationMins: args.durationMins, tz: args.tz,
    workHours: args.workHours || { start: "09:00", end: "18:00" }
  };
  if (args.attendeeAlias) {
    const hit = getColleague(args.attendeeAlias);
    if (hit?.ics_url) body.coworkerICS = hit.ics_url;
  }
  return await callGAS(c.webAppUrl, body);
}


src/modules/calendarBook/nlp.ts

import chrono from "chrono-node";

export type Parsed =
  | { intent: "schedule"; title: string; date: string; hhmm?: string | null; dur: number; alias?: string }
  | { intent: "find_free"; date: string; dur: number; alias?: string };

const DEF_TITLE = "Meeting";
const DEF_DUR = 30;

function d2(d: Date) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`; }
function t2(d: Date) { return `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`; }

function titleFrom(s: string) {
  const m = s.match(/\b(called|titled|for)\s+([^,]{3,80})/i) || s.match(/(?:create|schedule|book)\s+(?:a\s+)?([^,]{3,80})/i);
  let t = m?.[2] ?? m?.[1] ?? "";
  t = (t || "").replace(/\b(meeting|event)\b/i, "").trim();
  return t || DEF_TITLE;
}
function durFrom(s: string) {
  const m = s.match(/\b(\d+)\s*(min|mins|minutes|hr|hrs|hour|hours)\b/i);
  if (m) return /hr|hour/i.test(m[2]) ? +m[1]*60 : +m[1];
  if (/\bhalf\s*hour\b/i.test(s)) return 30;
  if (/\bquarter\s*hour\b/i.test(s)) return 15;
  return DEF_DUR;
}
function aliasFrom(s: string) {
  const q = s.match(/"([^"]+)"/); if (q) return q[1].trim();
  const w = s.match(/\bwith\s+([a-z0-9._\\-@ ]{2,60})/i); if (w) return w[1].trim();
  return undefined;
}

export function parseCommand(text: string, now = new Date()): Parsed {
  const s = text.trim();
  const res = chrono.parse(s, now);
  let date = d2(now);
  let hhmm: string | null | undefined = undefined;
  if (res.length) {
    const r = res[0];
    const st = r.start?.date();
    if (st) {
      date = d2(st);
      if (r.start.isCertain("hour") || r.start.isCertain("minute")) hhmm = t2(st);
    }
  }
  const dur = durFrom(s);
  const alias = aliasFrom(s);
  const title = titleFrom(s);
  const wantsFind = /\\b(find|free|availability|slot|when)\\b/i.test(s) && !hhmm;
  if (wantsFind) return { intent: "find_free", date, dur, alias };
  return { intent: "schedule", title, date, hhmm, dur, alias };
}


src/modules/calendarBook/index.ts

import express from "express";
import { parseCommand } from "./nlp.js";
import { scheduleViaProxy, freeViaProxy } from "./service.js";

const router = express.Router();

router.post("/command", async (req, res) => {
  try {
    const { userId, text, tz = "America/Vancouver", workHours } = req.body || {};
    if (!userId || !text) return res.status(400).json({ error: "userId and text required" });

    const p = parseCommand(text);
    if (p.intent === "find_free") {
      const f = await freeViaProxy(userId, { date: p.date, durationMins: p.dur, tz, workHours, attendeeAlias: p.alias });
      return res.json({ intent: "find_free", date: p.date, durationMins: p.dur, tz, windows: f.free?.slice(0, 5) || [] });
    }

    const out = await scheduleViaProxy(userId, {
      title: p.title, date: p.date, preferredStart: p.hhmm || null,
      durationMins: p.dur, tz, workHours, attendeeAlias: p.alias
    });
    return res.json(out);
  } catch (e: any) {
    return res.status(500).json({ error: e.message });
  }
});

router.post("/schedule", async (req, res) => {
  try {
    const { userId, title, date, preferredStart, durationMins = 30, tz = "America/Vancouver", workHours, attendeeAlias } = req.body || {};
    if (!userId || !title || !date) return res.status(400).json({ error: "userId, title, date required" });
    const out = await scheduleViaProxy(userId, { title, date, preferredStart: preferredStart || null, durationMins, tz, workHours, attendeeAlias });
    res.json(out);
  } catch (e: any) { res.status(500).json({ error: e.message }); }
});

export default router;


Minimal /calendar-proxy (ONLY if you don’t already have one and it’s mounted):

import express from "express";
const router = express.Router();
const REGISTRY = new Map<string, { webAppUrl: string; sharedToken: string }>();

router.post("/register", (req, res) => {
  const { userId, webAppUrl, sharedToken } = req.body || {};
  if (!userId || !webAppUrl || !sharedToken) return res.status(400).json({ error: "userId, webAppUrl, sharedToken required" });
  REGISTRY.set(String(userId), { webAppUrl: String(webAppUrl), sharedToken: String(sharedToken) });
  res.json({ ok: true });
});

router.post("/schedule", async (req, res) => {
  const { userId, title, date, preferredStart, durationMins = 30, tz = "America/Vancouver", workHours, coworkerICS, attendeeEmail } = req.body || {};
  if (!userId || !title || !date) return res.status(400).json({ error: "userId,title,date required" });
  const cfg = REGISTRY.get(String(userId));
  if (!cfg) return res.status(401).json({ error: "Not registered. Save connector in Calendar Credentials." });

  const payload: any = {
    action: "schedule", sharedToken: cfg.sharedToken,
    title, date, durationMins, tz, preferredStart: preferredStart || undefined,
    workHours: workHours || { start: "09:00", end: "18:00" }
  };
  if (coworkerICS) payload.coworkerICS = coworkerICS;
  if (attendeeEmail) payload.attendeeEmail = attendeeEmail;

  const r = await fetch(cfg.webAppUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
  const txt = await r.text();
  let data: any = null; try { data = JSON.parse(txt); } catch {}
  if (!r.ok) return res.status(502).json({ error: data?.error || txt || r.statusText });
  if (!data || data.error) return res.status(502).json({ error: data?.error || "GAS returned no data" });
  res.json(data);
});

export default router;


src/index.ts (mount exactly these, once)

import express from "express";
import calendarCred from "./modules/calendarCred/index.js";
import calendarBook from "./modules/calendarBook/index.js";
import calendarProxy from "./modules/calendarProxy/index.js"; // or your existing one

const app = express();
app.use(express.json({ limit: "1mb" }));

// REMOVE old mounts for /calendar-multi, old alias stores, quick actions, etc.

app.get("/health", (_req, res) => res.json({ ok: true, backend: process.env.CALENDAR_BACKEND || "proxy" }));
app.use("/calendar-cred", calendarCred);
app.use("/calendar-book", calendarBook);
app.use("/calendar-proxy", calendarProxy);

const PORT = Number(process.env.PORT || 3000);
app.listen(PORT, () => {
  console.log("[CAL] :%d", PORT);
  console.log("[CAL-CRED] GET  /calendar-cred/state");
  console.log("[CAL-CRED] POST /calendar-cred/user");
  console.log("[CAL-CRED] POST /calendar-cred/colleague");
  console.log("[CAL-BOOK] POST /calendar-book/command");
  console.log("[CAL-BOOK] POST /calendar-book/schedule");
  console.log("[CAL-PROXY] POST /calendar-proxy/register");
  console.log("[CAL-PROXY] POST /calendar-proxy/schedule");
});


package.json/tsconfig as specified above.

After you finish

Set CALENDAR_BACKEND=proxy in Deployment secrets.

In the Calendar Credentials panel, Save connector + one colleague.

Run the two acceptance tests.
If anything fails, keep the new files but restore old mounts from z_deprecated/ and report the exact failing request + response body.