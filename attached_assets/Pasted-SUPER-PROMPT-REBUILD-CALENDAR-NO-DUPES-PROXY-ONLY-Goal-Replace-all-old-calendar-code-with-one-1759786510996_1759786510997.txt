SUPER-PROMPT — REBUILD CALENDAR (NO DUPES, PROXY ONLY)

Goal: Replace all old calendar code with one clean, additive stack that books events via Google Apps Script Web App (“proxy”) using credentials saved in a UI panel.
Definition of Done: After saving the Web App URL + Shared Token + colleague aliases in the panel, POST /calendar-book/command returns { eventId, htmlLink }.

Phase 0 — Rules (to avoid duplicates)

After this task, the only calendar routes allowed are:

/calendar-cred/* (UI saves connector + up to 10 colleagues)

/calendar-book/* (NLP + booking through proxy)

/calendar-proxy/* (use the existing proxy router; if none exists, create the minimal one provided below)

Quarantine ALL previous calendar & alias code (don’t delete, just move):

Move to z_deprecated/:

src/modules/calendarMulti/**

any calendar-multi/** mounts

old alias stores unrelated to calendar_credentials.db

any old “Quick Action” calendar form handlers

Remove their mounts from src/index.ts.

Environment (Deployment secrets):

CALENDAR_BACKEND=proxy

Phase 1 — Update dependencies

Edit package.json (merge if needed):

{
  "name": "calendar-solid",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "ts-node-dev --transpile-only --respawn src/index.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "better-sqlite3": "^9.6.0",
    "chrono-node": "^2.7.7",
    "express": "^4.19.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.12.12",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.6.3"
  }
}


Create/ensure tsconfig.json:

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}

Phase 2 — New single calendar stack
2.1 Credentials router — saves connector + colleagues

Create src/modules/calendarCred/index.ts:

import express from "express";
import Database from "better-sqlite3";

const router = express.Router();
const db = new Database("calendar_credentials.db");
db.exec(`
CREATE TABLE IF NOT EXISTS user_connector (
  user_id TEXT PRIMARY KEY,
  web_app_url TEXT NOT NULL,
  shared_token TEXT NOT NULL,
  updated_at INTEGER NOT NULL
);
CREATE TABLE IF NOT EXISTS colleagues (
  alias TEXT PRIMARY KEY,
  email TEXT,
  ics_url TEXT,
  updated_at INTEGER NOT NULL
);
`);

function upsertConnector(userId: string, webAppUrl: string, sharedToken: string) {
  const now = Date.now();
  db.prepare(`
    INSERT INTO user_connector(user_id,web_app_url,shared_token,updated_at)
    VALUES(?,?,?,?)
    ON CONFLICT(user_id) DO UPDATE SET
      web_app_url=excluded.web_app_url,
      shared_token=excluded.shared_token,
      updated_at=excluded.updated_at
  `).run(userId, webAppUrl, sharedToken, now);
}
function readConnector(userId: string) {
  return db.prepare(`SELECT user_id, web_app_url, shared_token FROM user_connector WHERE user_id=?`).get(userId);
}
function upsertColleague(alias: string, email?: string, ics?: string) {
  const now = Date.now();
  db.prepare(`
    INSERT INTO colleagues(alias,email,ics_url,updated_at)
    VALUES(?,?,?,?)
    ON CONFLICT(alias) DO UPDATE SET
      email=excluded.email,
      ics_url=excluded.ics_url,
      updated_at=excluded.updated_at
  `).run(alias.toLowerCase(), email || null, ics || null, now);
}
function deleteColleague(alias: string) {
  db.prepare(`DELETE FROM colleagues WHERE alias=?`).run(alias.toLowerCase());
}
function listColleagues() {
  return db.prepare(`SELECT alias,email,ics_url,updated_at FROM colleagues ORDER BY alias`).all();
}

router.get("/state", (req, res) => {
  const userId = String(req.query.userId || "PRIMARY_USER");
  res.json({ userId, connector: readConnector(userId) || null, colleagues: listColleagues() });
});

router.post("/user", async (req, res) => {
  const { userId, webAppUrl, sharedToken } = req.body || {};
  if (!userId || !webAppUrl || !sharedToken) return res.status(400).json({ error: "userId, webAppUrl, sharedToken required" });
  upsertConnector(userId, webAppUrl, sharedToken);
  // Auto-register with proxy so /calendar-proxy/schedule works
  const origin = `${req.protocol}://${req.get("host")}`;
  const r = await fetch(`${origin}/calendar-proxy/register`, {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId, webAppUrl, sharedToken })
  });
  const j = await r.json().catch(() => ({}));
  if (!r.ok) return res.status(400).json({ error: "Register failed", detail: j });
  res.json({ ok: true, registered: true });
});

router.post("/colleague", (req, res) => {
  const { alias, email, icsUrl } = req.body || {};
  if (!alias) return res.status(400).json({ error: "alias required" });
  if (!email && !icsUrl) return res.status(400).json({ error: "email or icsUrl required" });
  upsertColleague(String(alias), email ? String(email) : undefined, icsUrl ? String(icsUrl) : undefined);
  res.json({ ok: true });
});

router.delete("/colleague/:alias", (req, res) => {
  const alias = String(req.params.alias || "").toLowerCase();
  if (!alias) return res.status(400).json({ error: "alias required" });
  deleteColleague(alias);
  res.json({ ok: true });
});

export default router;

2.2 Service — call your GAS web app using saved creds

Create src/modules/calendarBook/service.ts:

import Database from "better-sqlite3";

const db = new Database("calendar_credentials.db");

function getConnector(userId: string) {
  return db.prepare(`SELECT web_app_url AS webAppUrl, shared_token AS sharedToken FROM user_connector WHERE user_id=?`).get(userId);
}
function getColleague(alias: string): { email?: string; ics_url?: string } | undefined {
  return db.prepare(`SELECT email, ics_url FROM colleagues WHERE alias=?`).get(alias.toLowerCase());
}

async function callGAS(webAppUrl: string, payload: any) {
  const r = await fetch(webAppUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
  const txt = await r.text();
  let data: any = null; try { data = JSON.parse(txt); } catch {}
  if (!r.ok) throw new Error(data?.error || txt || `GAS ${r.status}`);
  if (data?.error) throw new Error(String(data.error));
  return data;
}

export async function scheduleViaProxy(userId: string, args: {
  title: string; date: string; preferredStart?: string | null; durationMins: number; tz: string;
  workHours?: { start: string; end: string };
  attendeeAlias?: string;
}) {
  const c = getConnector(userId);
  if (!c) throw new Error("No connector saved for this userId. Open Calendar Credentials and Save Connector.");
  const body: any = {
    action: "schedule",
    sharedToken: c.sharedToken,
    title: args.title,
    date: args.date,
    preferredStart: args.preferredStart || undefined,
    durationMins: args.durationMins,
    tz: args.tz,
    workHours: args.workHours || { start: "09:00", end: "18:00" }
  };
  if (args.attendeeAlias) {
    const hit = getColleague(args.attendeeAlias);
    if (hit?.ics_url) body.coworkerICS = hit.ics_url;
    if (hit?.email) body.attendeeEmail = hit.email;
  }
  return await callGAS(c.webAppUrl, body);
}

export async function freeViaProxy(userId: string, args: {
  date: string; durationMins: number; tz: string; workHours?: { start: string; end: string };
  attendeeAlias?: string;
}) {
  const c = getConnector(userId);
  if (!c) throw new Error("No connector saved for this userId.");
  const body: any = {
    action: "getFreeSlots",
    sharedToken: c.sharedToken,
    date: args.date,
    durationMins: args.durationMins,
    tz: args.tz,
    workHours: args.workHours || { start: "09:00", end: "18:00" }
  };
  if (args.attendeeAlias) {
    const hit = getColleague(args.attendeeAlias);
    if (hit?.ics_url) body.coworkerICS = hit.ics_url;
  }
  return await callGAS(c.webAppUrl, body);
}

2.3 NLP — robust parsing of messy user text

Create src/modules/calendarBook/nlp.ts:

import chrono from "chrono-node";

export type Parsed =
  | { intent: "schedule"; title: string; date: string; hhmm?: string | null; dur: number; alias?: string }
  | { intent: "find_free"; date: string; dur: number; alias?: string };

const DEF_TITLE = "Meeting";
const DEF_DUR = 30;

function toDate(d: Date) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`; }
function toHHmm(d: Date) { return `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`; }

function titleFrom(s: string) {
  const m = s.match(/\b(called|titled|for)\s+([^,]{3,80})/i) || s.match(/(?:create|schedule|book)\s+(?:a\s+)?([^,]{3,80})/i);
  let t = m?.[2] ?? m?.[1] ?? "";
  t = (t || "").replace(/\b(meeting|event)\b/i, "").trim();
  return t || DEF_TITLE;
}
function durFrom(s: string) {
  const m = s.match(/\b(\d+)\s*(min|mins|minutes|hr|hrs|hour|hours)\b/i);
  if (m) return /hr|hour/i.test(m[2]) ? +m[1]*60 : +m[1];
  if (/\bhalf\s*hour\b/i.test(s)) return 30;
  if (/\bquarter\s*hour\b/i.test(s)) return 15;
  return DEF_DUR;
}
function aliasFrom(s: string) {
  const q = s.match(/"([^"]+)"/); if (q) return q[1].trim();
  const w = s.match(/\bwith\s+([a-z0-9._\-@ ]{2,60})/i); if (w) return w[1].trim();
  return undefined;
}

export function parseCommand(text: string, now = new Date()): Parsed {
  const s = text.trim();
  const res = chrono.parse(s, now);
  let date = toDate(now);
  let hhmm: string | null | undefined = undefined;
  if (res.length) {
    const r = res[0];
    const st = r.start?.date();
    if (st) {
      date = toDate(st);
      if (r.start.isCertain("hour") || r.start.isCertain("minute")) hhmm = toHHmm(st);
    }
  }
  const dur = durFrom(s);
  const alias = aliasFrom(s);
  const title = titleFrom(s);
  const wantsFind = /\b(find|free|availability|slot|when)\b/i.test(s) && !hhmm;
  if (wantsFind) return { intent: "find_free", date, dur, alias };
  return { intent: "schedule", title, date, hhmm, dur, alias };
}

2.4 Command router — single entry point

Create src/modules/calendarBook/index.ts:

import express from "express";
import { parseCommand } from "./nlp.js";
import { scheduleViaProxy, freeViaProxy } from "./service.js";

const router = express.Router();

/** NLP entry: POST /calendar-book/command */
router.post("/command", async (req, res) => {
  try {
    const { userId, text, tz = "America/Vancouver", workHours } = req.body || {};
    if (!userId || !text) return res.status(400).json({ error: "userId and text required" });

    const p = parseCommand(text);
    if (p.intent === "find_free") {
      const f = await freeViaProxy(userId, { date: p.date, durationMins: p.dur, tz, workHours, attendeeAlias: p.alias });
      return res.json({ intent: "find_free", date: p.date, durationMins: p.dur, tz, windows: f.free?.slice(0, 5) || [] });
    }

    const data = await scheduleViaProxy(userId, {
      title: p.title, date: p.date,
      preferredStart: p.hhmm || null,
      durationMins: p.dur, tz, workHours,
      attendeeAlias: p.alias
    });
    return res.json(data);
  } catch (e: any) {
    return res.status(500).json({ error: e.message });
  }
});

/** Direct entry (no NLP): POST /calendar-book/schedule */
router.post("/schedule", async (req, res) => {
  try {
    const { userId, title, date, preferredStart, durationMins = 30, tz = "America/Vancouver", workHours, attendeeAlias } = req.body || {};
    if (!userId || !title || !date) return res.status(400).json({ error: "userId, title, date required" });
    const data = await scheduleViaProxy(userId, { title, date, preferredStart: preferredStart || null, durationMins, tz, workHours, attendeeAlias });
    res.json(data);
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});

export default router;

2.5 (ONLY IF YOU DON’T ALREADY HAVE ONE) Minimal proxy router

If your project already has a working /calendar-proxy that calls your GAS Web App, keep it and skip this file. Do not create a second one.

Create ONLY IF ABSENT: src/modules/calendarProxy/index.ts:

import express from "express";
const router = express.Router();

const REGISTRY = new Map<string, { webAppUrl: string; sharedToken: string }>();

router.post("/register", (req, res) => {
  const { userId, webAppUrl, sharedToken } = req.body || {};
  if (!userId || !webAppUrl || !sharedToken) return res.status(400).json({ error: "userId, webAppUrl, sharedToken required" });
  REGISTRY.set(String(userId), { webAppUrl: String(webAppUrl), sharedToken: String(sharedToken) });
  res.json({ ok: true });
});

router.post("/schedule", async (req, res) => {
  const { userId, title, date, preferredStart, durationMins = 30, tz = "America/Vancouver", workHours, coworkerICS, attendeeEmail } = req.body || {};
  if (!userId || !title || !date) return res.status(400).json({ error: "userId,title,date required" });
  const cfg = REGISTRY.get(String(userId));
  if (!cfg) return res.status(401).json({ error: "Not registered. Save connector in Calendar Credentials." });

  const payload: any = {
    action: "schedule",
    sharedToken: cfg.sharedToken,
    title, date, durationMins, tz,
    preferredStart: preferredStart || undefined,
    workHours: workHours || { start: "09:00", end: "18:00" }
  };
  if (coworkerICS) payload.coworkerICS = coworkerICS;
  if (attendeeEmail) payload.attendeeEmail = attendeeEmail;

  const r = await fetch(cfg.webAppUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
  const txt = await r.text();
  let data: any = null; try { data = JSON.parse(txt); } catch {}
  if (!r.ok) return res.status(502).json({ error: data?.error || txt || r.statusText });
  if (!data || data.error) return res.status(502).json({ error: data?.error || "GAS returned no data" });
  res.json(data);
});

export default router;

Phase 3 — Wire routes and remove old mounts

Edit src/index.ts:

import express from "express";
import calendarCred from "./modules/calendarCred/index.js";
import calendarBook from "./modules/calendarBook/index.js";
// If you ALREADY have a proxy router mounted, keep that import; else use the minimal one above:
import calendarProxy from "./modules/calendarProxy/index.js";

const app = express();
app.use(express.json({ limit: "1mb" }));

// REMOVE any old mounts: /calendar-multi, /car-v2, /car-mode, alias stores, quick action calendar endpoints, etc.

app.get("/health", (_req, res) => res.json({ ok: true, backend: process.env.CALENDAR_BACKEND || "proxy" }));

app.use("/calendar-cred", calendarCred);
app.use("/calendar-book", calendarBook);
app.use("/calendar-proxy", calendarProxy);

const PORT = Number(process.env.PORT || 3000);
app.listen(PORT, () => {
  console.log(`[CAL] listening on :${PORT}`);
  console.log("[CAL-CRED] GET  /calendar-cred/state");
  console.log("[CAL-CRED] POST /calendar-cred/user");
  console.log("[CAL-CRED] POST /calendar-cred/colleague");
  console.log("[CAL-BOOK] POST /calendar-book/command");
  console.log("[CAL-BOOK] POST /calendar-book/schedule");
  console.log("[CAL-PROXY] POST /calendar-proxy/register");
  console.log("[CAL-PROXY] POST /calendar-proxy/schedule");
});

Phase 4 — Build & run
npm i
npm run build
npm start

Phase 5 — Use the UI and test (no duplicates anywhere)

Set secrets (Deployment):

CALENDAR_BACKEND=proxy


Save your connector in the UI panel (you already have the component; if not, wire your panel to call):

POST /calendar-cred/user with { userId, webAppUrl: "<GAS /exec>", sharedToken: "<your token>" }

Should return { ok: true, registered: true }.

Save colleagues (up to 10):

POST /calendar-cred/colleague with { alias, email?, icsUrl? }

Text booking (NLP path):

curl -sS -X POST https://<app>/calendar-book/command \
 -H 'Content-Type: application/json' \
 -d '{
   "userId":"PRIMARY_USER",
   "text":"create a team meeting today at 12:30 with \"boss\" for 30 minutes",
   "tz":"America/Vancouver",
   "workHours":{"start":"09:00","end":"18:00"}
 }'


→ Expect { "eventId": "...", "htmlLink": "..." }.

Direct booking (no NLP):

curl -sS -X POST https://<app>/calendar-book/schedule \
 -H 'Content-Type: application/json' \
 -d '{
   "userId":"PRIMARY_USER",
   "title":"Design Sync",
   "date":"2025-10-06",
   "preferredStart":"14:00",
   "durationMins":30,
   "tz":"America/Vancouver",
   "attendeeAlias":"boss"
 }'

Why this eliminates the mess

Single source of truth: calendar_credentials.db stores connector + colleagues. No other alias stores exist.

One booking path: /calendar-book/* → service.ts → your GAS Web App. No OAuth, no multi backends.

No duplicate routers: everything old moved to z_deprecated/, mounts removed.

Clear failure messages: if GAS rejects, you see the exact error; no vague 400s.

Do exactly this; you’ll end up with one calendar implementation, no repeats, and prompts that actually book.